package de.jexcellence.hibernate.entity;

import jakarta.persistence.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import org.hibernate.engine.spi.CascadingAction;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.Objects;

/**
 * AbstractEntity serves as a base class for all JPA entities in the application, providing
 * common functionality and standardized behavior for entity lifecycle management.
 *
 * <p>This abstract entity provides the following core features:</p>
 * <ul>
 *   <li>Auto-generated primary key using IDENTITY strategy</li>
 *   <li>Optimistic locking through version control</li>
 *   <li>Automatic timestamp management for creation and updates</li>
 *   <li>Soft delete functionality to preserve data integrity</li>
 *   <li>JPA lifecycle callbacks for custom entity behavior</li>
 *   <li>Standard equals, hashCode, and toString implementations</li>
 * </ul>
 *
 * <p>The entity uses Hibernate-specific annotations for automatic timestamp management
 * and provides built-in soft delete capabilities to avoid hard deletion of important data.
 * All extending entities inherit these features automatically.</p>
 *
 * <p>The class implements proper entity lifecycle management through JPA callbacks,
 * ensuring consistent behavior across all entity operations including persistence,
 * updates, and removal operations.</p>
 *
 * @author JExcellence
 * @version 1.0
 * @since 1.0
 * @see MappedSuperclass
 * @see Serializable
 * @see CreationTimestamp
 * @see UpdateTimestamp
 */
@MappedSuperclass
public abstract class AbstractEntity implements Serializable {
    
    /**
     * Serial version UID for ensuring serialization compatibility across different versions.
     *
     * <p>This constant ensures that serialized instances of entities extending this abstract
     * class remain compatible during application upgrades and deployments. The value should
     * be updated only when breaking changes are made to the entity structure that would
     * affect serialization compatibility.</p>
     *
     * @see Serializable
     */
    private static final long serialVersionUID = 1L;
    
    /**
     * The unique identifier for this entity, automatically generated by the database.
     *
     * <p>This field serves as the primary key for all entities extending this abstract class.
     * The identifier is automatically generated using the database's IDENTITY strategy,
     * which typically uses auto-increment columns in most database systems.</p>
     *
     * <p>The identifier is assigned when the entity is first persisted to the database
     * and remains immutable throughout the entity's lifecycle. A null value indicates
     * that the entity has not yet been persisted (is new).</p>
     *
     * @see Id
     * @see GeneratedValue
     * @see GenerationType#IDENTITY
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    /**
     * Version field used for optimistic locking to prevent lost updates in concurrent environments.
     *
     * <p>This field is automatically managed by JPA and is incremented each time the entity
     * is updated. It provides optimistic concurrency control by ensuring that updates are
     * only applied if the entity hasn't been modified by another transaction since it was loaded.</p>
     *
     * <p>When an update operation detects that the version has changed since the entity was
     * loaded, an OptimisticLockException is thrown, indicating that another transaction
     * has modified the entity concurrently.</p>
     *
     * <p>The version starts at 0 for new entities and is incremented with each update operation.</p>
     *
     * @see Version
     * @see jakarta.persistence.OptimisticLockException
     */
    @Version
    private int version;
    
    /**
     * Timestamp indicating when this entity was first created and persisted to the database.
     *
     * <p>This field is automatically populated by Hibernate when the entity is first persisted
     * using the {@code @CreationTimestamp} annotation. The timestamp reflects the exact moment
     * when the INSERT operation was executed in the database.</p>
     *
     * <p>The field is marked as non-updatable to ensure that the creation timestamp remains
     * immutable throughout the entity's lifecycle, preserving the audit trail integrity.
     * Any attempts to modify this field after persistence will be ignored by Hibernate.</p>
     *
     * <p>This timestamp is essential for audit trails, data analysis, and business logic
     * that depends on entity creation timing.</p>
     *
     * @see CreationTimestamp
     * @see Column#updatable()
     */
    @CreationTimestamp
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;
    
    /**
     * Timestamp indicating when this entity was last modified in the database.
     *
     * <p>This field is automatically updated by Hibernate whenever the entity is modified
     * using the {@code @UpdateTimestamp} annotation. The timestamp reflects the exact moment
     * when the most recent UPDATE operation was executed in the database.</p>
     *
     * <p>For new entities, this field is initially set to the same value as the creation
     * timestamp. Subsequently, it is updated automatically whenever any field in the entity
     * is modified and the entity is saved to the database.</p>
     *
     * <p>This timestamp is crucial for tracking entity modifications, implementing cache
     * invalidation strategies, and maintaining comprehensive audit trails.</p>
     *
     * @see UpdateTimestamp
     */
    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    /**
     * Flag indicating whether this entity has been soft deleted.
     *
     * <p>This boolean field implements soft delete functionality, allowing entities to be
     * marked as deleted without physically removing them from the database. This approach
     * preserves data integrity, maintains referential relationships, and enables audit trails.</p>
     *
     * <p>When set to {@code true}, the entity is considered deleted for business purposes
     * but remains in the database for historical and audit purposes. Application logic
     * should filter out soft-deleted entities from normal business operations.</p>
     *
     * <p>The field defaults to {@code false} for new entities and is marked as non-nullable
     * to ensure consistent state. The soft delete operation also triggers the update
     * timestamp mechanism to record when the deletion occurred.</p>
     *
     * <p>Benefits of soft deletion:</p>
     * <ul>
     *   <li>Preserves referential integrity with related entities</li>
     *   <li>Maintains complete audit trails and historical data</li>
     *   <li>Enables data recovery if deletion was performed in error</li>
     *   <li>Supports compliance requirements for data retention</li>
     * </ul>
     *
     * @see Column#nullable()
     */
    @Column(name = "deleted", nullable = false)
    private boolean deleted = false;
    
    /**
     * Default constructor required by JPA specification.
     *
     * <p>This constructor is used by Hibernate for entity instantiation during
     * database operations. It initializes the entity with default values including
     * setting the deleted flag to false.</p>
     */
    public AbstractEntity() {
    }
    
    /**
     * JPA lifecycle callback executed before entity persistence.
     *
     * <p>This method ensures that timestamp fields are properly initialized
     * if they haven't been set explicitly. It provides a fallback mechanism
     * for timestamp management in case the Hibernate annotations fail to work.</p>
     *
     * <p>The method is automatically called by the JPA provider before the
     * entity is persisted to the database for the first time.</p>
     *
     * @see PrePersist
     */
    @PrePersist
    protected void onPrePersist() {
        if (Objects.isNull(this.createdAt)) {
            this.createdAt = LocalDateTime.now();
        }
        if (Objects.isNull(this.updatedAt)) {
            this.updatedAt = LocalDateTime.now();
        }
    }
    
    /**
     * JPA lifecycle callback executed before entity updates.
     *
     * <p>This method automatically updates the updatedAt timestamp whenever
     * the entity is modified. It ensures that the last modification time
     * is always accurately recorded.</p>
     *
     * <p>The method is automatically called by the JPA provider before any
     * update operation is performed on the entity.</p>
     *
     * @see PreUpdate
     */
    @PreUpdate
    protected void onPreUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
    
    /**
     * JPA lifecycle callback executed after entity persistence.
     *
     * <p>This method provides a hook for custom logic that should be executed
     * after the entity has been successfully persisted to the database.
     * Subclasses can override this method to implement specific post-persistence behavior.</p>
     *
     * <p>The method is automatically called by the JPA provider after the
     * entity has been persisted and the transaction is committed.</p>
     *
     * @see PostPersist
     */
    @PostPersist
    protected void onPostPersist() {
    }
    
    /**
     * JPA lifecycle callback executed after entity updates.
     *
     * <p>This method provides a hook for custom logic that should be executed
     * after the entity has been successfully updated in the database.
     * Subclasses can override this method to implement specific post-update behavior.</p>
     *
     * <p>The method is automatically called by the JPA provider after the
     * entity has been updated and the transaction is committed.</p>
     *
     * @see PostUpdate
     */
    @PostUpdate
    protected void onPostUpdate() {
    }
    
    /**
     * JPA lifecycle callback executed before entity removal.
     *
     * <p>This method provides a hook for custom logic that should be executed
     * before the entity is removed from the database. Subclasses can override
     * this method to implement cleanup logic or validation before removal.</p>
     *
     * <p>The method is automatically called by the JPA provider before the
     * entity is removed from the database.</p>
     *
     * @see PreRemove
     */
    @PreRemove
    protected void onPreRemove() {
    }
    
    /**
     * Performs a soft delete operation on the entity.
     *
     * <p>This method marks the entity as deleted without actually removing it
     * from the database. This approach preserves data integrity and allows for
     * audit trails while effectively removing the entity from normal operations.</p>
     *
     * <p>The method also triggers the update timestamp mechanism to record
     * when the soft delete operation occurred. If the entity is already marked
     * as deleted, no operation is performed.</p>
     *
     * <p>Soft deletion is preferred over hard deletion in most business applications
     * to maintain referential integrity and enable data recovery if needed.</p>
     */
    public void softDelete() {
        if (!this.deleted) {
            this.deleted = true;
            this.onPreUpdate();
        }
    }
    
    /**
     * Determines whether this entity is new (not yet persisted).
     *
     * <p>An entity is considered new if its identifier is null, indicating
     * that it hasn't been assigned a primary key by the database yet.
     * This method is useful for determining whether to perform an insert
     * or update operation.</p>
     *
     * @return true if the entity is new (id is null), false if it has been persisted
     */
    public boolean isNew() {
        return Objects.isNull(this.id);
    }
    
    /**
     * Retrieves the unique identifier of this entity.
     *
     * <p>The identifier is automatically generated by the database using
     * the IDENTITY strategy when the entity is first persisted.</p>
     *
     * @return the entity's unique identifier, or null if the entity is new
     */
    public Long getId() {
        return this.id;
    }
    
    /**
     * Sets the unique identifier of this entity.
     *
     * <p>This method can only be called on new entities (before persistence).
     * Attempting to modify the identifier of a persisted entity will result
     * in an IllegalStateException to maintain data integrity.</p>
     *
     * <p>In most cases, the identifier should be left null to allow the
     * database to generate it automatically using the IDENTITY strategy.</p>
     *
     * @param id the unique identifier to set
     * @throws IllegalStateException if attempting to set the id on a persisted entity
     */
    public void setId(final Long id) {
        if (!this.isNew()) {
            throw new IllegalStateException("Id cannot be set after entity persistence.");
        }
        this.id = id;
    }
    
    /**
     * Retrieves the version number used for optimistic locking.
     *
     * <p>The version is automatically managed by JPA and is incremented
     * with each update operation. This mechanism prevents lost updates
     * in concurrent environments.</p>
     *
     * @return the current version number of the entity
     */
    public int getVersion() {
        return this.version;
    }
    
    /**
     * Sets the version number for optimistic locking.
     *
     * <p>This method is typically used by the JPA provider and should
     * rarely be called directly by application code. Manual version
     * management can interfere with optimistic locking mechanisms.</p>
     *
     * @param version the version number to set
     */
    public void setVersion(final int version) {
        this.version = version;
    }
    
    /**
     * Retrieves the timestamp when this entity was created.
     *
     * <p>The creation timestamp is automatically set when the entity
     * is first persisted and cannot be modified afterwards to maintain
     * audit trail integrity.</p>
     *
     * @return the creation timestamp, or null if not yet set
     */
    public LocalDateTime getCreatedAt() {
        return this.createdAt;
    }
    
    /**
     * Sets the creation timestamp for this entity.
     *
     * <p>This method can only be called on new entities (before persistence).
     * Attempting to modify the creation timestamp of a persisted entity
     * will result in an IllegalStateException to maintain audit integrity.</p>
     *
     * <p>In most cases, this timestamp is automatically managed by Hibernate
     * annotations and doesn't need to be set manually.</p>
     *
     * @param createdAt the creation timestamp to set
     * @throws IllegalStateException if attempting to modify the timestamp on a persisted entity
     */
    public void setCreatedAt(final LocalDateTime createdAt) {
        if (!this.isNew()) {
            throw new IllegalStateException("CreatedAt cannot be modified after entity persistence.");
        }
        this.createdAt = createdAt;
    }
    
    /**
     * Retrieves the timestamp when this entity was last updated.
     *
     * <p>The update timestamp is automatically maintained by Hibernate
     * and reflects the most recent modification time of the entity.</p>
     *
     * @return the last update timestamp, or null if not yet set
     */
    public LocalDateTime getUpdatedAt() {
        return this.updatedAt;
    }
    
    /**
     * Sets the last update timestamp for this entity.
     *
     * <p>While this method allows manual setting of the update timestamp,
     * it's typically managed automatically by Hibernate annotations.
     * Manual updates should be used carefully to avoid inconsistencies.</p>
     *
     * @param updatedAt the update timestamp to set
     */
    public void setUpdatedAt(final LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }
    
    /**
     * Checks whether this entity has been soft deleted.
     *
     * <p>Soft deleted entities remain in the database but are marked
     * as deleted to exclude them from normal business operations while
     * preserving them for audit purposes.</p>
     *
     * @return true if the entity is soft deleted, false otherwise
     */
    public boolean isDeleted() {
        return this.deleted;
    }
    
    /**
     * Sets the deletion status of this entity.
     *
     * <p>When setting the entity as deleted (true), this method automatically
     * performs a soft delete operation which includes updating the timestamp.
     * When setting as not deleted (false), it simply clears the deletion flag.</p>
     *
     * <p>This method provides a convenient way to manage the deletion state
     * while ensuring proper timestamp management for audit purposes.</p>
     *
     * @param deleted true to mark the entity as deleted, false to unmark it
     */
    public void setDeleted(final boolean deleted) {
        if (deleted) {
            this.softDelete();
        } else {
            this.deleted = false;
        }
    }
    
    /**
     * Compares this entity with another object for equality.
     *
     * <p>Two entities are considered equal if they are of the same type
     * and have the same identifier. This implementation follows JPA
     * best practices for entity equality comparison.</p>
     *
     * <p>Note that new entities (with null ids) are only equal to themselves,
     * ensuring proper behavior in collections before persistence.</p>
     *
     * @param o the object to compare with this entity
     * @return true if the objects are equal, false otherwise
     */
    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (!(o instanceof AbstractEntity that)) return false;
        return Objects.equals(this.id, that.id);
    }
    
    /**
     * Generates a hash code for this entity based on its identifier.
     *
     * <p>The hash code is computed using the entity's identifier to ensure
     * consistency with the equals method. This implementation is safe for
     * use in hash-based collections like HashMap and HashSet.</p>
     *
     * <p>For new entities with null identifiers, this will return a
     * consistent hash code based on the null value.</p>
     *
     * @return the hash code for this entity
     */
    @Override
    public int hashCode() {
        return Objects.hash(this.id);
    }
    
    /**
     * Returns a string representation of this entity.
     *
     * <p>The string representation includes the class name and all
     * key properties including id, version, timestamps, and deletion status.
     * This format is useful for debugging and logging purposes.</p>
     *
     * <p>The format follows the pattern: ClassName{property=value, ...}</p>
     *
     * @return a string representation of this entity
     */
    @Override
    public String toString() {
        return this.getClass().getSimpleName() + "{" +
               "id=" + this.id +
               ", version=" + this.version +
               ", createdAt=" + this.createdAt +
               ", updatedAt=" + this.updatedAt +
               ", deleted=" + this.deleted +
               '}';
    }
}